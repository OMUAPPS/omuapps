import json
import re
from pathlib import Path
from typing import TypedDict

import tomlkit
from packaging.requirements import Requirement
from packaging.specifiers import SpecifierSet


def get_lerna_version():
    lerna = Path("lerna.json")
    if not lerna.exists():
        raise FileNotFoundError(f"Could not find {lerna}")
    return json.loads(lerna.read_bytes())["version"]


class Project(TypedDict):
    name: str
    version: str
    dependencies: list[str]


def read_project(project: Path) -> Project:
    toml = project / "pyproject.toml"
    if not toml.exists():
        raise FileNotFoundError(f"Could not find {toml}")
    data = tomlkit.loads(toml.read_text(encoding="utf-8")).value
    return Project(data["project"])


def write_project(project: Path, data: Project):
    toml = project / "pyproject.toml"
    parsed = tomlkit.loads(toml.read_text(encoding="utf-8"))
    parsed["project"] = data
    encoded_toml = parsed.as_string().encode(encoding="utf-8")
    toml.write_bytes(encoded_toml)


def gen_version(project: Project, path: Path):
    version_path = path / "src" / project["name"] / "version.py"
    version_path.write_bytes(
        f"""\
# Do not edit this file, it is automatically generated by scripts/py-generate_version.py
VERSION = "{project['version']}"
""".encode()
    )


def set_version(project: Path, version: str):
    toml = project / "pyproject.toml"
    toml.write_bytes(
        re.sub(
            r"version\s*=\s*\"([0-9.]*)\"",
            f'version = "{version}"',
            toml.read_text(encoding="utf-8"),
        ).encode()
    )


def update_version(version: str | None = None):
    new_version = version or get_lerna_version()
    py_packages = list(Path("packages-py").glob("*"))
    package_versions: dict[str, str] = {}
    for pypackage in py_packages:
        project = read_project(pypackage)
        print(f"[{pypackage.name}] {project['version']} -> {new_version}")
        project["version"] = new_version
        set_version(pypackage, new_version)
        gen_version(project, pypackage)
        package_versions[project["name"]] = project["version"]
    for pypackage in py_packages:
        project = read_project(pypackage)
        dependencies: dict[str, Requirement] = {}
        for dep in project["dependencies"]:
            requirement = Requirement(dep)
            name = requirement.name
            if name is None:
                raise ValueError(f"Illegal requirement {dep} in {pypackage}")
            dependencies[name] = requirement
        for dep in dependencies:
            if dep not in package_versions:
                continue
            dependency = dependencies[dep]
            updated_version = SpecifierSet(f">={package_versions[dep]}")
            if updated_version == dependency.specifier:
                continue
            dependency.specifier = updated_version
            print(f"[{pypackage.name}] {dep} -> {dependency}")
        project["dependencies"] = [str(dependencies[dep]) for dep in dependencies]
        write_project(pypackage, project)

    version_json_paths = {
        Path("packages-js/dash/src/lib/version.json"),
        Path("packages-js/site/src/lib/version.json"),
    }

    for version_path in version_json_paths:
        version_path.write_bytes((json.dumps({"version": new_version}) + "\n").encode())

    version_ts_paths = {
        Path("packages-js/plugin-obs/src/version.ts"),
        Path("packages-js/omu/src/version.ts"),
    }

    for version_path in version_ts_paths:
        version_path.write_bytes(f"export const VERSION = '{new_version}';\n".encode())

    # pub static VERSION: &str = "0.1.0";
    version_path = Path("packages-js/dash/src-tauri/src/version.rs")
    version_path.write_bytes(f'pub static VERSION: &str = "{new_version}";\n'.encode())

    tauri_path = Path("packages-js/dash/src-tauri/tauri.conf.json")
    tauri = json.loads(tauri_path.read_bytes())
    tauri["package"]["version"] = new_version
    tauri_path.write_bytes((json.dumps(tauri, indent=4) + "\n").encode())


if __name__ == "__main__":
    update_version()
